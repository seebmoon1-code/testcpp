#include <iostream>
#include <cstring>
#include <string>
#include <sstream>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <thread>
#include <mutex>
#include <atomic>

using namespace std;

// --- تنظیمات ثابت (Const Settings) ---
const int PORT = 8080;
const int BACKLOG = 10;
const int BUFFER_SIZE = 1024;

// --- منابع عمومی و همزمان ---
// استفاده از atomic برای شمارنده ساده و امن در محیط چندنخی
atomic<int> counter(0); 
mutex cout_mutex; // برای امن کردن خروجی استاندارد (cout)

/**
 * @brief  ساخت پاسخ ساده HTTP
 * @param content محتوای بدنه (Body) پاسخ
 * @param status_code کد وضعیت (مثلا 200 یا 404)
 * @param content_type نوع محتوا (معمولا text/html)
 * @return رشته کامل پاسخ HTTP
 */
string build_http_response(const string& content, int status_code, const string& content_type = "text/html") {
    stringstream response;
    string status_text = (status_code == 200) ? "OK" : "Not Found";
    
    response << "HTTP/1.1 " << status_code << " " << status_text << "\r\n";
    response << "Content-Type: " << content_type << "\r\n";
    response << "Content-Length: " << content.length() << "\r\n";
    response << "Connection: close\r\n"; // برای سادگی، اتصال را می‌بندیم.
    response << "\r\n"; // خط خالی برای جداسازی هدرها از بدنه
    response << content;
    
    return response.str();
}

/**
 * @brief  هندلر اصلی برای مدیریت درخواست‌های کلاینت
 * @param client_socket سوکت اتصال کلاینت
 */
void handle_client(int client_socket) {
    char buffer[BUFFER_SIZE] = {0};
    string response_str;
    
    // ۱. دریافت درخواست
    long valread = read(client_socket, buffer, BUFFER_SIZE - 1);
    
    if (valread > 0) {
        string request(buffer);
        
        // تشخیص متد و مسیر درخواست
        size_t method_end = request.find(' ');
        size_t path_start = method_end + 1;
        size_t path_end = request.find(' ', path_start);
        
        if (method_end != string::npos && path_end != string::npos) {
            string method = request.substr(0, method_end);
            string path = request.substr(path_start, path_end - path_start);

            // نمایش درخواست در کنسول (با قفل برای عدم تداخل)
            {
                lock_guard<mutex> lock(cout_mutex);
                cout << "درخواست از " << this_thread::get_id() << ": " << method << " " << path << endl;
            }

            // ۲. منطق مسیردهی (Routing)
            if (path == "/") {
                string content = 
                    "<!DOCTYPE html>"
                    "<html><body>"
                    "<h1>خوش آمدید، ای فرمانده!</h1>"
                    "<p>این وب سرور C++ مینیمال و پر قو با Multithreading است.</p>"
                    "<p>برای دیدن شمارنده، به مسیر <a href=\"/count\">/count</a> بروید.</p>"
                    "</body></html>";
                response_str = build_http_response(content, 200);
            } 
            else if (path == "/count") {
                // افزایش شمارنده با امنیت Thread
                int current_count = ++counter; 
                
                string content = 
                    "<!DOCTYPE html>"
                    "<html><body>"
                    "<h1>شمارنده</h1>"
                    "<p>این صفحه " + to_string(current_count) + " بار بازدید شده است.</p>"
                    "<p>آزمون اتصال موازی با موفقیت انجام شد.</p>"
                    "</body></html>";
                response_str = build_http_response(content, 200);
            } 
            else {
                // ۴۰۴ - پیدا نشد
                string content = "<h1>404 - پیدا نشد</h1><p>مسیر مورد نظر وجود ندارد.</p>";
                response_str = build_http_response(content, 404);
            }
        }
    }
    
    // ۳. ارسال پاسخ و بستن سوکت
    send(client_socket, response_str.c_str(), response_str.length(), 0);
    close(client_socket);
}

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    
    // ۱. ایجاد سوکت
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }
    
    // برای استفاده مجدد از آدرس بلافاصله پس از بسته شدن (اختیاری اما خوب)
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    // تنظیم آدرس سرور
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY; 
    address.sin_port = htons(PORT);
       
    // ۲. اتصال سوکت به آدرس و پورت
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
       
    // ۳. گوش دادن برای اتصال‌ها
    if (listen(server_fd, BACKLOG) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    cout << "وب سرور C++ شما در حال اجرا است. پورت: " << PORT << endl;
    cout << "شروع به پذیرش اتصالات موازی با Threading..." << endl;
    
    // حلقه اصلی سرور برای پذیرش اتصال‌ها
    while (true) {
        // ۴. پذیرش اتصال جدید (بلوکه می‌کند تا یک کلاینت وصل شود)
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
            perror("accept");
            continue; 
        }
        
        // ۵. ارسال اتصال به یک نخ (Thread) جدید برای پردازش موازی
        // نخ جدید ایجاد می‌شود تا وظیفه را مدیریت کند و نخ اصلی (main) به حلقه باز می‌گردد.
        thread client_thread(handle_client, new_socket);
        client_thread.detach(); // جدا کردن نخ از نخ اصلی تا به طور مستقل اجرا شود.
    }
    
    return 0;
}
